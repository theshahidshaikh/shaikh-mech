import { PulleyItem, Client, AppSettings, User } from '../types';
import { auth, db } from './firebase';
import { 
  signInWithEmailAndPassword, 
  createUserWithEmailAndPassword, 
  updateProfile 
} from "firebase/auth";
import { 
  collection, 
  query, 
  where, 
  getDocs, 
  addDoc, 
  setDoc, 
  doc, 
  deleteDoc, 
  updateDoc 
} from "firebase/firestore";

// Helper to get current user ID safely
const getUserId = () => {
  const user = auth.currentUser;
  if (!user) throw new Error("User not authenticated");
  return user.uid;
};

// ==========================================
// FIREBASE API SERVICE
// ==========================================
export const api = {
  // --- AUTH ---
  login: async (email: string, password: string, companyName?: string, companyDetails?: any): Promise<{ user: User, settings: AppSettings }> => {
    try {
      let userCredential;
      let settings: AppSettings;
      
      if (companyName) {
        // REGISTER FLOW
        userCredential = await createUserWithEmailAndPassword(auth, email, password);
        const user = userCredential.user;
        
        // Save initial Settings to Firestore
        settings = {
          companyName: companyName,
          companyAddress: companyDetails?.address || '',
          gstNo: companyDetails?.gstNo || '',
          defaultRate: 6,
          boreRate: 50,
          currency: ''
        };
        
        // Create user settings document
        await setDoc(doc(db, "settings", user.uid), settings);

      } else {
        // LOGIN FLOW
        userCredential = await signInWithEmailAndPassword(auth, email, password);
        
        // Fetch Settings
        const settingsSnap = await getDocs(query(collection(db, "settings"), where("__name__", "==", userCredential.user.uid)));
        if (!settingsSnap.empty) {
            settings = settingsSnap.docs[0].data() as AppSettings;
        } else {
            // Fallback default settings if missing
            settings = {
                companyName: 'My Company',
                companyAddress: '',
                gstNo: '',
                defaultRate: 6,
                boreRate: 50,
                currency: ''
            };
        }
      }

      return { 
        user: { email: userCredential.user.email || '', companyName: settings.companyName }, 
        settings 
      };
    } catch (error: any) {
      console.error("Firebase Auth Error:", error);
      throw new Error(error.message);
    }
  },

  // --- ITEMS ---
  getItems: async (): Promise<PulleyItem[]> => {
    try {
      const q = query(collection(db, "items"), where("userId", "==", getUserId()));
      const querySnapshot = await getDocs(q);
      const items: PulleyItem[] = [];
      querySnapshot.forEach((doc) => {
        // Combine Firestore ID with data, but ensure 'id' field exists for app logic
        items.push({ ...doc.data(), id: doc.id } as PulleyItem);
      });
      // Sort by date desc (client side sort for simplicity with indexes)
      return items.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    } catch (e) {
      console.error("Error getting items: ", e);
      return [];
    }
  },

  saveItem: async (item: PulleyItem): Promise<PulleyItem> => {
    const uid = getUserId();
    const itemData = { ...item, userId: uid };
    
    // If item has a Firestore ID (it was edited), update it
    // Note: The app generates a random string ID for 'id'. 
    // We should check if we are creating new or updating based on logic.
    // However, Firestore creates its own IDs.
    
    // Strategy: We query to see if an item with this specific application 'id' exists
    // If so update, else add.
    
    const q = query(collection(db, "items"), where("id", "==", item.id), where("userId", "==", uid));
    const querySnapshot = await getDocs(q);
    
    if (!querySnapshot.empty) {
        // Update existing
        const docId = querySnapshot.docs[0].id;
        await updateDoc(doc(db, "items", docId), itemData);
        return { ...itemData, id: docId } as any; // Return logic id
    } else {
        // Create new
        const docRef = await addDoc(collection(db, "items"), itemData);
        // We keep the internal 'id' generated by the app for consistency
        return item;
    }
  },

  deleteItem: async (id: string): Promise<void> => {
    const uid = getUserId();
    const q = query(collection(db, "items"), where("id", "==", id), where("userId", "==", uid));
    const querySnapshot = await getDocs(q);
    querySnapshot.forEach(async (d) => {
        await deleteDoc(doc(db, "items", d.id));
    });
  },

  // --- CLIENTS ---
  getClients: async (): Promise<Client[]> => {
    try {
      const q = query(collection(db, "clients"), where("userId", "==", getUserId()));
      const querySnapshot = await getDocs(q);
      const clients: Client[] = [];
      querySnapshot.forEach((doc) => {
        clients.push({ ...doc.data(), id: doc.data().id } as Client);
      });
      return clients;
    } catch (e) {
      return [];
    }
  },

  saveClient: async (client: Client): Promise<Client> => {
    const uid = getUserId();
    await addDoc(collection(db, "clients"), { ...client, userId: uid });
    return client;
  },

  updateClient: async (client: Client): Promise<Client> => {
    const uid = getUserId();
    const q = query(collection(db, "clients"), where("id", "==", client.id), where("userId", "==", uid));
    const querySnapshot = await getDocs(q);
    if (!querySnapshot.empty) {
        await updateDoc(doc(db, "clients", querySnapshot.docs[0].id), { ...client, userId: uid });
    }
    return client;
  },

  deleteClient: async (id: string): Promise<void> => {
    const uid = getUserId();
    const q = query(collection(db, "clients"), where("id", "==", id), where("userId", "==", uid));
    const querySnapshot = await getDocs(q);
    querySnapshot.forEach(async (d) => {
        await deleteDoc(doc(db, "clients", d.id));
    });
  },

  // --- SETTINGS ---
  saveSettings: async (settings: AppSettings): Promise<AppSettings> => {
    const uid = getUserId();
    await setDoc(doc(db, "settings", uid), settings);
    return settings;
  }
};
